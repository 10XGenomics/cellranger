use crate::{io_utils, BarcodeConstruct, BarcodeSegment, BcSegSeq, GelBeadAndProbeConstruct};
use anyhow::{bail, ensure, Context, Result};
use itertools::{process_results, Itertools};
use martian::{AsMartianPrimaryType, MartianStruct};
use martian_derive::MartianStruct;
use metric::{TxHashMap, TxHashSet};
use serde::{Deserialize, Serialize};
use std::io::BufRead;
use std::ops::Range;
use std::path::{Path, PathBuf};
use strum_macros::Display;

/// Different ways to specify a whitelist of sequences (typically barcode sequence)
#[derive(Serialize, Deserialize, Clone, PartialEq, Eq, Debug, Hash)]
#[serde(into = "WhitelistSpecFlat", try_from = "WhitelistSpecFlat")]
#[serde(untagged)]
pub enum WhitelistSpec {
    // NOTE: if you add, remove, or alter fields here, you MUST update the
    // fields contained in the WhitelistSpecFlat helper struct below.
    /// Historically we have specified barcode whitelists using a name. A txt file with that name
    /// would be located in the `lib/python/cellranger/barcodes` folder.
    TxtFile { name: String },
    /// A translation whitelist dynamically generated by the pipeline.
    DynamicTranslation { translation_whitelist_path: PathBuf },
    SlideFile {
        slide: String,
        part: slide_design::OligoPart,
    },
}

impl WhitelistSpec {
    pub fn slide_name(&self) -> Option<&String> {
        if let WhitelistSpec::SlideFile { slide, .. } = self {
            Some(slide)
        } else {
            None
        }
    }
}

impl AsMartianPrimaryType for WhitelistSpec {
    fn as_martian_primary_type() -> martian::MartianPrimaryType {
        martian::MartianPrimaryType::Struct(martian::StructDef::new(
            "WhitelistSpec".to_string(),
            WhitelistSpecFlat::mro_fields(),
        ))
    }
}

/// Helper struct to flatten a WhitelistSpec into a martian struct.
#[derive(Serialize, Deserialize, Default, MartianStruct)]
struct WhitelistSpecFlat {
    name: Option<String>,
    #[mro_type = "file"]
    translation_whitelist_path: Option<PathBuf>,
    slide: Option<String>,
    part: Option<slide_design::OligoPart>,
}

impl From<WhitelistSpec> for WhitelistSpecFlat {
    fn from(value: WhitelistSpec) -> Self {
        match value {
            WhitelistSpec::TxtFile { name } => Self {
                name: Some(name),
                ..Self::default()
            },
            WhitelistSpec::DynamicTranslation {
                translation_whitelist_path,
            } => Self {
                translation_whitelist_path: Some(translation_whitelist_path),
                ..Self::default()
            },
            WhitelistSpec::SlideFile { slide, part } => Self {
                slide: Some(slide),
                part: Some(part),
                ..Self::default()
            },
        }
    }
}

impl TryFrom<WhitelistSpecFlat> for WhitelistSpec {
    type Error = anyhow::Error;

    fn try_from(value: WhitelistSpecFlat) -> Result<Self> {
        match (
            value.name,
            value.translation_whitelist_path,
            value.slide,
            value.part,
        ) {
            (Some(name), None, None, None) => Ok(Self::TxtFile { name }),
            (None, Some(path), None, None) => Ok(Self::DynamicTranslation {
                translation_whitelist_path: path,
            }),
            (None, None, Some(slide), Some(part)) => Ok(Self::SlideFile { slide, part }),
            too_many => bail!("too many fields set in whitelist spec: {:?}", too_many),
        }
    }
}

/// Should mirror `WhitelistSpec`.
/// `WhitelistSource` would have the full path to the apropriate files that
/// contains the whitelist sequences. There are convenience functions to access
/// the whitelist as a set/vec/map etc.
#[derive(Debug)]
pub enum WhitelistSource {
    /// A headerless TSV file of barcode sequences, optional translated barcode sequences, and optional identifier.
    TxtFile { path: PathBuf },
    /// A translation whitelist, always contains two sequences.
    DynamicTranslation { path: PathBuf },
    SlideFile {
        path: PathBuf,
        part: slide_design::OligoPart,
    },
}

/// The identifier given to a particular barcode or collection of related barcodes.
pub type BarcodeId = crate::ShortString7;

/// The known types of multiplexing barcode identifiers.
#[derive(Copy, Clone, Display, PartialEq, Eq)]
pub enum MultiplexingBarcodeType {
    CMO,
    #[strum(to_string = "Gene Expression (BC)")]
    RTL,
    #[strum(to_string = "Antibody Capture (AB)")]
    Antibody,
    Overhang,
}

/// Categorize the provided multiplexing barcode ID by type.
/// Assume that any unrecognized identifier is a (potentially user-provided) CMO ID.
/// BC001-BC024 are RTL multiplexing barcodes.
/// BC025-BC999 and ABxxx are antibody multiplexing barcodes.
pub fn categorize_multiplexing_barcode_id(bc_id: &str) -> MultiplexingBarcodeType {
    use MultiplexingBarcodeType::{Antibody, Overhang, CMO, RTL};
    match (&bc_id[..2], bc_id[2..].parse::<usize>().ok()) {
        ("BC", Some(..=24)) => RTL,
        ("BC", Some(25..)) | ("AB", Some(_)) => Antibody,
        ("OH", Some(_)) => Overhang,
        _ => CMO,
    }
}

type Entry = (BcSegSeq, Option<BcSegSeq>, Option<BarcodeId>);

impl WhitelistSource {
    pub fn txt_file(path: &Path) -> Self {
        WhitelistSource::TxtFile {
            path: path.to_path_buf(),
        }
    }

    pub fn from_spec(
        spec: &WhitelistSpec,
        translation: bool,
        assay: Option<Assay>,
    ) -> Result<Self> {
        Ok(match spec {
            WhitelistSpec::TxtFile { name } => WhitelistSource::TxtFile {
                path: find_whitelist(name, translation, assay)?,
            },
            WhitelistSpec::DynamicTranslation {
                translation_whitelist_path: whitelist_path,
            } => WhitelistSource::DynamicTranslation {
                path: whitelist_path.clone(),
            },
            WhitelistSpec::SlideFile { slide, part } => WhitelistSource::SlideFile {
                path: find_whitelist(slide, translation, assay)?,
                part: *part,
            },
        })
    }

    pub fn construct(
        spec: BarcodeConstruct<&WhitelistSpec>,
        gel_bead_translation: bool,
        assay: Option<Assay>,
    ) -> Result<BarcodeConstruct<Self>> {
        let translation = match spec {
            BarcodeConstruct::GelBeadOnly(_) => BarcodeConstruct::GelBeadOnly(gel_bead_translation),
            BarcodeConstruct::GelBeadAndProbe(_) => {
                assert!(
                    !gel_bead_translation,
                    "Fixed RNA Profiling only supports feature barcoding for singleplex"
                );
                // A given pool of barcoded RTL probes are a mix of four barcodes to base balance
                // in sequencing. We map the four barcodes in the mix to a single barcode using
                // translation machinery
                BarcodeConstruct::GelBeadAndProbe(GelBeadAndProbeConstruct {
                    gel_bead: gel_bead_translation,
                    probe: true,
                })
            }
            c => {
                assert!(
                    !gel_bead_translation,
                    "Do not expect translation in some barcodes"
                );
                c.map(|_| false)
            }
        };

        spec.zip(translation)
            .map_result(|(s, t)| WhitelistSource::from_spec(s, t, assay))
    }

    fn path(&self) -> &Path {
        match self {
            Self::TxtFile { path } => path,
            Self::DynamicTranslation { path } => path,
            Self::SlideFile { path, .. } => path,
        }
    }

    fn is_translation(&self) -> bool {
        match self {
            WhitelistSource::TxtFile { path } => {
                // if the parent directory is "translation"
                path.parent()
                    .and_then(|p| p.file_name().map(|d| d == "translation"))
                    .unwrap_or(false)
            }
            WhitelistSource::DynamicTranslation { .. } => true,
            WhitelistSource::SlideFile { .. } => false,
        }
    }

    pub fn iter(&self) -> Result<Box<dyn Iterator<Item = Result<Entry>> + '_>> {
        let iter = match self {
            WhitelistSource::TxtFile { path } | WhitelistSource::DynamicTranslation { path } => {
                Box::new(
                    io_utils::open_with_gz(path)
                        .with_context(|| "whitelist file not found")?
                        .lines()
                        .map(|line| line.with_context(|| path.display().to_string()))
                        .map_ok(|line| {
                            // could be a translation whitelist, take left only
                            let mut iter = line.split_whitespace();
                            let lhs = BcSegSeq::from_bytes(iter.next().unwrap().as_bytes());
                            let rhs = iter.next().map(|x| BcSegSeq::from_bytes(x.as_bytes()));
                            let id = iter.next().map(|id| BarcodeId::try_from(id).unwrap());
                            (lhs, rhs, id)
                        }),
                ) as Box<dyn Iterator<Item = Result<Entry>>>
            }
            WhitelistSource::SlideFile { path, part } => Box::new(
                Vec::from_iter(
                    slide_design::load_oligos(path, *part)?
                        .iter()
                        .map(|s| Ok((BcSegSeq::from_bytes(s.as_bytes()), None, None))),
                )
                .into_iter(),
            ),
        };
        Ok(iter)
    }

    /// Read the barcode whitelist and return a vector of BcSegSeq.
    pub fn as_vec(&self) -> Result<Vec<BcSegSeq>> {
        self.iter()?.map_ok(|x| x.0).collect()
    }

    /// Read the barcode whitelist and return a set of BcSegSeq.
    pub fn as_set(&self) -> Result<TxHashSet<BcSegSeq>> {
        self.iter()?.map_ok(|x| x.0).collect()
    }

    /// Read the barcode whitelist and return a map of BCsegSeq to integers.
    pub fn as_map(&self) -> Result<TxHashMap<BcSegSeq, u32>> {
        self.iter()?
            .enumerate()
            .map(|(i, x)| x.map(|x| (x.0, i as u32)))
            .collect()
    }

    /// Read the barcode (translation) whitelist and return a map of BCsegSeq to BcSegSeq.
    pub fn as_translation(&self) -> Result<TxHashMap<BcSegSeq, BcSegSeq>> {
        self.iter()?
            .map(|x| {
                if let (raw_seq, Some(trans_seq), _) = x? {
                    Ok((raw_seq, trans_seq))
                } else {
                    bail!("not a translation whitelist: {self:?}")
                }
            })
            .collect()
    }

    pub fn as_whitelist(&self) -> Result<Whitelist> {
        if self.is_translation() {
            Ok(Whitelist::Trans(self.as_translation()?))
        } else {
            Ok(Whitelist::Plain(self.as_set()?))
        }
    }

    pub fn as_translation_seq_to_id(&self) -> Result<TxHashMap<BcSegSeq, BarcodeId>> {
        self.iter()?
            .map(|x| match x? {
                (_raw_seq, Some(trans_seq), Some(id)) => Ok((trans_seq, id)),
                (_, None, _) | (_, _, None) => {
                    bail!("Barcode translation whitelist requires three columns")
                }
            })
            .collect()
    }

    pub fn as_raw_seq_to_id(&self) -> Result<TxHashMap<BcSegSeq, BarcodeId>> {
        self.iter()?
            .map(|x| match x? {
                (raw_seq, Some(_trans_seq), Some(id)) => Ok((raw_seq, id)),
                (_, None, _) | (_, _, None) => {
                    bail!("Barcode translation whitelist requires three columns")
                }
            })
            .collect()
    }

    /// Return a sorted vector of the barcode IDs.
    pub fn get_ids(&self) -> Result<Vec<BarcodeId>> {
        process_results(self.iter()?, |iter| {
            iter.map(|x| x.2.unwrap()).sorted().dedup().collect()
        })
    }

    /// Create a translation whitelist from this whitelist and provided map.
    ///
    /// The output whitelist will always be a translation-style whitelist.
    /// All barcodes provided in the ID mapping will be mapped to the target
    /// barcode. All barcodes not involved in a translation pair
    /// will be included verbatim in the output whitelist.
    /// More than one barcode may be mapped to the same target.
    ///
    /// Note that this implementation is not optimized for very large whitelists
    /// and may need to be refactored for such a use case.
    pub fn create_translation_from_id_map<'a>(
        &'a self,
        id_map: &'a TxHashMap<BarcodeId, BarcodeId>,
    ) -> Result<impl Iterator<Item = (BcSegSeq, BcSegSeq, BarcodeId)> + 'a> {
        ensure!(
            self.is_translation(),
            "cannot create a mapped translation of whitelist {} because it itself is not a translation whitelist",
            self.path().display()
        );

        // Load the whitelist and generate the mapping from ID to translated sequence.
        let mut id_to_translated_seq: TxHashMap<BarcodeId, BcSegSeq> = TxHashMap::default();
        let entries: Vec<_> = self
            .iter()?
            .map(|entry| {
                let (raw_seq, trans_seq, id) = entry?;
                let (trans_seq, id) = (trans_seq.unwrap(), id.unwrap());
                let existing = id_to_translated_seq.entry(id).or_insert(trans_seq);
                ensure!(
                    existing == &trans_seq,
                    "found multiple translated sequences for barcode {id}: {existing} {trans_seq}",
                );
                Ok((raw_seq, id))
            })
            .try_collect()?;

        // Now use our two mappings to translate the whitelist.  Maintain
        // the order of the original whitelist to ease debugging.
        Ok(entries.into_iter().map(move |(raw_seq, original_id)| {
            let translated_id = id_map.get(&original_id).unwrap_or(&original_id);

            let new_translated_seq = id_to_translated_seq.get(translated_id).unwrap_or_else(|| {
                panic!(
                    "{translated_id} not found in whitelist {}",
                    self.path().display()
                )
            });
            (raw_seq, *new_translated_seq, *translated_id)
        }))
    }
}

#[derive(Serialize)]
pub enum Whitelist {
    Plain(TxHashSet<BcSegSeq>),
    Trans(TxHashMap<BcSegSeq, BcSegSeq>),
}

impl Whitelist {
    pub fn new(p: &Path) -> Result<Self> {
        WhitelistSource::txt_file(p).as_whitelist()
    }

    // Range of length of sequences in this whitelist
    pub fn sequence_lengths(&self) -> Range<usize> {
        let mut lengths = TxHashSet::default();
        match self {
            Whitelist::Plain(ref seqs) => {
                for s in seqs {
                    lengths.insert(s.len());
                }
            }
            Whitelist::Trans(ref seqs) => {
                for (s1, s2) in seqs {
                    lengths.insert(s1.len());
                    lengths.insert(s2.len());
                }
            }
        }
        lengths
            .into_iter()
            .minmax()
            .into_option()
            .map_or(0..0, |(min, max)| min..max + 1)
    }

    pub fn construct(
        spec: BarcodeConstruct<&WhitelistSpec>,
        gel_bead_translation: bool,
        assay: Option<Assay>,
    ) -> Result<BarcodeConstruct<Self>> {
        WhitelistSource::construct(spec, gel_bead_translation, assay)?
            .map_result(|w| w.as_whitelist())
    }

    pub fn check(&self, bc_segment: &mut BarcodeSegment) -> bool {
        let seq_in_wl = match self {
            Whitelist::Plain(ref whitelist) => whitelist.contains(&bc_segment.sequence),
            Whitelist::Trans(ref whitelist) => {
                if let Some(translation) = whitelist.get(&bc_segment.sequence) {
                    bc_segment.sequence = *translation;
                    true
                } else {
                    false
                }
            }
        };
        bc_segment.state.change(seq_in_wl);
        seq_in_wl
    }

    pub fn contains(&self, sequence: &BcSegSeq) -> bool {
        match self {
            Whitelist::Plain(ref whitelist) => whitelist.contains(sequence),
            Whitelist::Trans(ref whitelist) => whitelist.contains_key(sequence),
        }
    }

    // - Return `sseq` if it is in the whitelist
    // - If there's a single N in the barcode, check if we can can replace the N with a valid base &
    // get a whitelist hit. This makes us robust to N-cycles. Return the first modified sequence if
    // we found one.
    // - Otherwise return None
    pub fn match_to_whitelist(&self, sseq: BcSegSeq) -> Option<BcSegSeq> {
        if self.contains(&sseq) {
            return Some(sseq);
        }
        if let Some((pos, _)) = sseq.seq().iter().find_position(|&&base| base == b'N') {
            for base in b"ACGT" {
                let mut mutated = sseq.seq().to_vec();
                mutated[pos] = *base;
                let new_sseq = BcSegSeq::from_bytes(&mutated);
                if self.contains(&new_sseq) {
                    return Some(new_sseq);
                }
            }
        }
        None
    }
}

/// Represents different locations in the repo for a barcode whitelist. GEX barcodes are located in
/// lib/python/cellranger, while ATAC barcodes are located in lib/python/atac
#[derive(Debug, Copy, Clone)]
pub enum Assay {
    GEX,
    ATAC,
}

impl Assay {
    fn folder(&self) -> &'static str {
        match self {
            Assay::GEX => "cellranger",
            Assay::ATAC => "atac",
        }
    }
}

fn search_for_whitelist(
    whitelist_name: &str,
    translation: bool,
    mut p: PathBuf,
) -> Option<PathBuf> {
    if translation {
        return search_for_whitelist(whitelist_name, false, p.join("translation"));
    }
    if p.is_dir() {
        p.push(whitelist_name);

        let p_gz = p.with_extension("txt.gz");
        if p_gz.is_file() {
            return Some(p_gz);
        }

        p.set_extension("txt");
        if p.is_file() {
            return Some(p);
        }

        // Slide design file
        p.set_extension("slide");
        if p.is_file() {
            return Some(p);
        }
    }

    None
}

/// Find the path to a barcode whitelist file, given the whitelist name.
/// This searches the known relative paths between built rust executables
/// and the barcode whitelist folder.
pub fn find_whitelist(
    whitelist_name: &str,
    translation: bool,
    assay: Option<Assay>,
) -> Result<PathBuf> {
    let exe = bazel_utils::current_exe()?;
    let exe_path = exe.parent().unwrap().to_path_buf();
    let assay_folder = assay.unwrap_or(Assay::GEX).folder();

    let mut barcode_search_paths = Vec::new();

    // Option 1: find relative to the PYTHONPATH and default to ../python, since in a Cell
    // Ranger build the exe will be at lib/bin/<exe>, and the barcodes are at
    // lib/python/barcodes. So we try "<exe path>/../python/cellranger/barcodes"
    for ppath in std::env::var("PYTHONPATH")
        .unwrap_or_else(|_| String::from("../python"))
        .split(':')
        .filter(|path| path.ends_with("python"))
    {
        barcode_search_paths.push(format!("{ppath}/{assay_folder}/barcodes"));
    }

    // Option 2: in a checkout on disk and a cargo build, the exe will be at
    // lib/rust/target/release/<exe>, and the barcodes are at lib/python/barcodes.
    // So we try "<exe path>/../../../python/cellranger/barcodes"
    barcode_search_paths.push(format!("../../../python/{assay_folder}/barcodes"));

    // Option 3: in a checkout on disk, the cargo test build exe will be at
    // lib/rust/target/release/deps/<exe>, and the barcodes are at lib/python/barcodes.
    // So we try "<exe path>/../../../../python/cellranger/barcodes"
    barcode_search_paths.push(format!("../../../../python/{assay_folder}/barcodes"));

    // Option 4: in a checkout on disk using the --target flag, the cargo test build exe will be at
    // lib/rust/target/release/deps/<target>/<exe>, and the barcodes are at lib/python/barcodes.
    // So we try "<exe path>/../../../../../python/cellranger/barcodes"
    barcode_search_paths.push(format!("../../../../../python/{assay_folder}/barcodes"));

    // Option 5: find relative to the current working directory, in case we're
    // running under cargo test. When running tests under bazel test the cwd is
    // lib/rust/cr_[atac|lib] => we want to go ../../python/cellranger/barcodes
    barcode_search_paths.push(format!("../../python/{assay_folder}/barcodes"));

    for rel_path in &barcode_search_paths {
        let wl_path = search_for_whitelist(whitelist_name, translation, exe_path.join(rel_path));
        if let Some(p) = wl_path {
            return Ok(std::fs::canonicalize(p)?);
        }
    }

    // cr_lib can be used as a library, use debug_assertions as proxy for dev builds
    // Option 6: find relative to the CARGO_MANIFEST_DIR, which may happen
    // if you've set your CARGO_HOME to a non-default value.
    #[cfg(debug_assertions)]
    {
        let path = format!(
            "{}/../../python/{}/barcodes",
            env!("CARGO_MANIFEST_DIR"),
            assay_folder,
        );
        let wl_path = search_for_whitelist(whitelist_name, translation, path.into());
        if let Some(p) = wl_path {
            return Ok(std::fs::canonicalize(p)?);
        }
    }

    bail!(
        "Couldn't find the barcode whitelist {} (translation: {})in the following paths:\n{}",
        whitelist_name,
        translation,
        barcode_search_paths
            .iter()
            .enumerate()
            .map(|(i, p)| format!("{i} {:?}", exe_path.join(p)))
            .join("\n")
    )
}

#[cfg(test)]
mod test {

    use super::*;
    use std::io::Write;

    #[test]
    fn test_match_to_whitelist() {
        use metric::set;
        let wl = Whitelist::Plain(set![BcSegSeq::from_bytes(b"ACGT")]);
        assert_eq!(
            wl.match_to_whitelist(BcSegSeq::from_bytes(b"ACGT")),
            Some(BcSegSeq::from_bytes(b"ACGT"))
        );
        assert_eq!(wl.match_to_whitelist(BcSegSeq::from_bytes(b"AAAT")), None);
        assert_eq!(
            wl.match_to_whitelist(BcSegSeq::from_bytes(b"ANGT")),
            Some(BcSegSeq::from_bytes(b"ACGT"))
        );
    }

    #[test]
    fn test_find_whitelist() -> Result<()> {
        let _ = find_whitelist("737K-august-2016", false, None)?;
        assert!(find_whitelist("737K-august-2016", true, None).is_err());
        let _ = find_whitelist("3M-february-2018", false, None)?;
        let _ = find_whitelist("3M-february-2018", true, None)?;
        let _ = find_whitelist("9K-LT-march-2021", false, None)?;
        let _ = find_whitelist("9K-LT-march-2021", true, None)?;
        let _ = find_whitelist("737K-arc-v1", false, Some(Assay::ATAC))?;
        Ok(())
    }

    #[test]
    fn test_whitelist_spec_serde() -> Result<()> {
        let specs = vec![
            WhitelistSpec::TxtFile {
                name: "foo".to_string(),
            },
            WhitelistSpec::DynamicTranslation {
                translation_whitelist_path: PathBuf::from("/test"),
            },
            WhitelistSpec::SlideFile {
                slide: "test_slide".to_string(),
                part: slide_design::OligoPart::Bc1,
            },
        ];
        let de: Vec<WhitelistSpec> = serde_json::from_str(&serde_json::to_string(&specs)?)?;
        assert_eq!(de, specs);
        Ok(())
    }

    #[test]
    fn test_create_translation_from_id_map() -> Result<()> {
        let input_lines = owned_string_vecs(vec![
            vec!["ACTG", "AAAA", "BC0"],
            vec!["ATCG", "AAAA", "BC0"],
            vec!["CTAG", "TTTT", "BC1"],
            vec!["CGAT", "TTTT", "BC1"],
            vec!["TACG", "CCCC", "BC2"],
            vec!["TCAG", "GGGG", "BC3"],
            vec!["GACT", "CCCC", "BC4"],
            vec!["GCAT", "GGCC", "BC5"],
        ]);
        let mut file = tempfile::NamedTempFile::new()?;
        for line in input_lines {
            writeln!(file, "{}", line.join("\t"))?;
        }
        let source = WhitelistSource::DynamicTranslation {
            path: file.path().into(),
        };
        let mapping: TxHashMap<BarcodeId, BarcodeId> =
            [("BC1", "BC0"), ("BC2", "BC0"), ("BC4", "BC3")]
                .into_iter()
                .map(|(id0, id1)| {
                    (
                        BarcodeId::try_from(id0).unwrap(),
                        BarcodeId::try_from(id1).unwrap(),
                    )
                })
                .collect();

        let translated: Vec<_> = source
            .create_translation_from_id_map(&mapping)?
            .map(|(s0, s1, id)| vec![s0.to_string(), s1.to_string(), id.to_string()])
            .collect();

        let expected = owned_string_vecs(vec![
            vec!["ACTG", "AAAA", "BC0"],
            vec!["ATCG", "AAAA", "BC0"],
            vec!["CTAG", "AAAA", "BC0"],
            vec!["CGAT", "AAAA", "BC0"],
            vec!["TACG", "AAAA", "BC0"],
            vec!["TCAG", "GGGG", "BC3"],
            vec!["GACT", "GGGG", "BC3"],
            vec!["GCAT", "GGCC", "BC5"],
        ]);

        assert_eq!(translated, expected);

        Ok(())
    }

    fn owned_string_vecs(input: Vec<Vec<&str>>) -> Vec<Vec<String>> {
        input
            .into_iter()
            .map(|inner| inner.into_iter().map(String::from).collect())
            .collect()
    }
}
